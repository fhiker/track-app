{
  "version": 3,
  "sources": ["../../urql/src/context.ts", "../../urql/src/hooks/state.ts", "../../urql/src/hooks/useMutation.ts", "../../urql/src/hooks/useRequest.ts", "../../urql/src/hooks/cache.ts", "../../urql/src/hooks/useQuery.ts", "../../urql/src/hooks/useSubscription.ts", "../../urql/src/components/Mutation.ts", "../../urql/src/components/Query.ts", "../../urql/src/components/Subscription.ts"],
  "sourcesContent": ["import * as React from 'react';\nimport { Client } from '@urql/core';\n\nconst OBJ = {};\n\n/** `urql`'s React Context.\n *\n * @remarks\n * The React Context that `urql`’s {@link Client} will be provided with.\n * You may use the reexported {@link Provider} to provide a `Client` as well.\n */\nexport const Context: import('react').Context<Client | object> =\n  React.createContext(OBJ);\n\n/** Provider for `urql`'s {@link Client} to GraphQL hooks.\n *\n * @remarks\n * `Provider` accepts a {@link Client} and provides it to all GraphQL hooks,\n * and {@link useClient}.\n *\n * You should make sure to create a {@link Client} and provide it with the\n * `Provider` to parts of your component tree that use GraphQL hooks.\n *\n * @example\n * ```tsx\n * import { Provider } from 'urql';\n * // All of `@urql/core` is also re-exported by `urql`:\n * import { Client, cacheExchange, fetchExchange } from '@urql/core';\n *\n * const client = new Client({\n *   url: 'https://API',\n *   exchanges: [cacheExchange, fetchExchange],\n * });\n *\n * const App = () => (\n *   <Provider value={client}>\n *     <Component />\n *   </Provider>\n * );\n * ```\n */\nexport const Provider: React.Provider<Client | object> = Context.Provider;\n\n/** React Consumer component, providing the {@link Client} provided on a parent component.\n * @remarks\n * This is an alias for {@link Context.Consumer}.\n */\nexport const Consumer: React.Consumer<Client | object> = Context.Consumer;\n\nContext.displayName = 'UrqlContext';\n\n/** Hook returning a {@link Client} from {@link Context}.\n *\n * @remarks\n * `useClient` is a convenience hook, which accesses `urql`'s {@link Context}\n * and returns the {@link Client} defined on it.\n *\n * This will be the {@link Client} you passed to a {@link Provider}\n * you wrapped your elements containing this hook with.\n *\n * @throws\n * In development, if the component you call `useClient()` in is\n * not wrapped in a {@link Provider}, an error is thrown.\n */\nexport const useClient = (): Client => {\n  const client = React.useContext(Context);\n\n  if (client === OBJ && process.env.NODE_ENV !== 'production') {\n    const error =\n      \"No client has been specified using urql's Provider. please create a client and add a Provider.\";\n\n    console.error(error);\n    throw new Error(error);\n  }\n\n  return client as Client;\n};\n", "import * as React from 'react';\n\nexport const initialState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n  operation: undefined,\n};\n\n// Two operations are considered equal if they have the same key\nconst areOperationsEqual = (\n  a: { key: number } | undefined,\n  b: { key: number } | undefined\n) => {\n  return a === b || !!(a && b && a.key === b.key);\n};\n\n/**\n * Checks if two objects are shallowly different with a special case for\n * 'operation' where it compares the key if they are not the otherwise equal\n */\nconst isShallowDifferent = <T extends Record<string, any>>(a: T, b: T) => {\n  for (const key in a) if (!(key in b)) return true;\n  for (const key in b) {\n    if (\n      key === 'operation'\n        ? !areOperationsEqual(a[key], b[key])\n        : a[key] !== b[key]\n    ) {\n      return true;\n    }\n  }\n  return false;\n};\n\ninterface Stateish {\n  data?: any;\n  error?: any;\n  fetching: boolean;\n  stale: boolean;\n}\n\nexport const computeNextState = <T extends Stateish>(\n  prevState: T,\n  result: Partial<T>\n): T => {\n  const newState: T = {\n    ...prevState,\n    ...result,\n    data:\n      result.data !== undefined || result.error ? result.data : prevState.data,\n    fetching: !!result.fetching,\n    stale: !!result.stale,\n  };\n\n  return isShallowDifferent(prevState, newState) ? newState : prevState;\n};\n\nexport const hasDepsChanged = <T extends { length: number }>(a: T, b: T) => {\n  for (let i = 0, l = b.length; i < l; i++) if (a[i] !== b[i]) return true;\n  return false;\n};\n\nconst reactSharedInternals = (React as any)\n  .__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nexport function deferDispatch<Dispatch extends React.Dispatch<any>>(\n  setState: Dispatch,\n  value: Dispatch extends React.Dispatch<infer State> ? State : void\n) {\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    !!reactSharedInternals &&\n    !!reactSharedInternals.ReactCurrentOwner &&\n    !!reactSharedInternals.ReactCurrentOwner.current\n  ) {\n    Promise.resolve(value).then(setState);\n  } else {\n    setState(value);\n  }\n}\n", "import * as React from 'react';\nimport { pipe, onPush, filter, toPromise, take } from 'wonka';\n\nimport {\n  AnyVariables,\n  DocumentInput,\n  OperationResult,\n  OperationContext,\n  CombinedError,\n  createRequest,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { deferDispatch, initialState } from './state';\n\n/** State of the last mutation executed by your {@link useMutation} hook.\n *\n * @remarks\n * `UseMutationState` is returned (in a tuple) by {@link useMutation} and\n * gives you the {@link OperationResult} of the last mutation executed\n * with {@link UseMutationExecute}.\n *\n * Even if the mutation document passed to {@link useMutation} changes,\n * the state isn’t reset, so you can keep displaying the previous result.\n */\nexport interface UseMutationState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> {\n  /** Indicates whether `useMutation` is currently executing a mutation. */\n  fetching: boolean;\n  /** Indicates that the mutation result is not fresh.\n   *\n   * @remarks\n   * The `stale` flag is set to `true` when a new result for the mutation\n   * is expected.\n   * This is mostly unused for mutations and will rarely affect you, and\n   * is more relevant for queries.\n   *\n   * @see {@link OperationResult.stale} for the source of this value.\n   */\n  stale: boolean;\n  /** The {@link OperationResult.data} for the executed mutation. */\n  data?: Data;\n  /** The {@link OperationResult.error} for the executed mutation. */\n  error?: CombinedError;\n  /** The {@link OperationResult.extensions} for the executed mutation. */\n  extensions?: Record<string, any>;\n  /** The {@link Operation} that the current state is for.\n   *\n   * @remarks\n   * This is the mutation {@link Operation} that has last been executed.\n   * When {@link UseQueryState.fetching} is `true`, this is the\n   * last `Operation` that the current state was for.\n   */\n  operation?: Operation<Data, Variables>;\n}\n\n/** Triggers {@link useMutation} to execute its GraphQL mutation operation.\n *\n * @param variables - variables using which the mutation will be executed.\n * @param context - optionally, context options that will be merged with the hook's\n * {@link UseQueryArgs.context} options and the `Client`’s options.\n * @returns the {@link OperationResult} of the mutation.\n *\n * @remarks\n * When called, {@link useMutation} will start the GraphQL mutation\n * it currently holds and use the `variables` passed to it.\n *\n * Once the mutation response comes back from the API, its\n * returned promise will resolve to the mutation’s {@link OperationResult}\n * and the {@link UseMutationState} will be updated with the result.\n *\n * @example\n * ```ts\n * const [result, executeMutation] = useMutation(UpdateTodo);\n * const start = async ({ id, title }) => {\n *   const result = await executeMutation({ id, title });\n * };\n */\nexport type UseMutationExecute<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = (\n  variables: Variables,\n  context?: Partial<OperationContext>\n) => Promise<OperationResult<Data, Variables>>;\n\n/** Result tuple returned by the {@link useMutation} hook.\n *\n * @remarks\n * Similarly to a `useState` hook’s return value,\n * the first element is the {@link useMutation}’s state, updated\n * as mutations are executed with the second value, which is\n * used to start mutations and is a {@link UseMutationExecute}\n * function.\n */\nexport type UseMutationResponse<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = [UseMutationState<Data, Variables>, UseMutationExecute<Data, Variables>];\n\n/** Hook to create a GraphQL mutation, run by passing variables to the returned execute function.\n *\n * @param query - a GraphQL mutation document which `useMutation` will execute.\n * @returns a {@link UseMutationResponse} tuple of a {@link UseMutationState} result,\n * and an execute function to start the mutation.\n *\n * @remarks\n * `useMutation` allows GraphQL mutations to be defined and keeps its state\n * after the mutation is started with the returned execute function.\n *\n * Given a GraphQL mutation document it returns state to keep track of the\n * mutation state and a {@link UseMutationExecute} function, which accepts\n * variables for the mutation to be executed.\n * Once called, the mutation executes and the state will be updated with\n * the mutation’s result.\n *\n * @see {@link https://urql.dev/goto/urql/docs/basics/react-preact/#mutations} for `useMutation` docs.\n *\n * @example\n * ```ts\n * import { gql, useMutation } from 'urql';\n *\n * const UpdateTodo = gql`\n *   mutation ($id: ID!, $title: String!) {\n *     updateTodo(id: $id, title: $title) {\n *       id, title\n *     }\n *   }\n * `;\n *\n * const UpdateTodo = () => {\n *   const [result, executeMutation] = useMutation(UpdateTodo);\n *   const start = async ({ id, title }) => {\n *     const result = await executeMutation({ id, title });\n *   };\n *   // ...\n * };\n * ```\n */\nexport function useMutation<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(query: DocumentInput<Data, Variables>): UseMutationResponse<Data, Variables> {\n  const isMounted = React.useRef(true);\n  const client = useClient();\n\n  const [state, setState] =\n    React.useState<UseMutationState<Data, Variables>>(initialState);\n\n  const executeMutation = React.useCallback(\n    (variables: Variables, context?: Partial<OperationContext>) => {\n      deferDispatch(setState, { ...initialState, fetching: true });\n      return pipe(\n        client.executeMutation<Data, Variables>(\n          createRequest<Data, Variables>(query, variables),\n          context || {}\n        ),\n        onPush(result => {\n          if (isMounted.current) {\n            deferDispatch(setState, {\n              fetching: false,\n              stale: result.stale,\n              data: result.data,\n              error: result.error,\n              extensions: result.extensions,\n              operation: result.operation,\n            });\n          }\n        }),\n        filter(result => !result.hasNext),\n        take(1),\n        toPromise\n      );\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [client, query, setState]\n  );\n\n  React.useEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  return [state, executeMutation];\n}\n", "import * as React from 'react';\nimport {\n  AnyVariables,\n  DocumentInput,\n  GraphQLRequest,\n  createRequest,\n} from '@urql/core';\n\n/** Creates a request from a query and variables but preserves reference equality if the key isn't changing\n * @internal\n */\nexport function useRequest<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(\n  query: DocumentInput<Data, Variables>,\n  variables: Variables\n): GraphQLRequest<Data, Variables> {\n  const prev = React.useRef<undefined | GraphQLRequest<Data, Variables>>(\n    undefined\n  );\n\n  return React.useMemo(() => {\n    const request = createRequest<Data, Variables>(query, variables);\n    // We manually ensure reference equality if the key hasn't changed\n    if (prev.current !== undefined && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n}\n", "import { pipe, subscribe } from 'wonka';\nimport { Client, OperationResult } from '@urql/core';\n\ntype CacheEntry = OperationResult | Promise<unknown> | undefined;\n\ninterface Cache {\n  get(key: number): CacheEntry;\n  set(key: number, value: CacheEntry): void;\n  dispose(key: number): void;\n}\n\ninterface ClientWithCache extends Client {\n  _react?: Cache;\n}\n\nexport const getCacheForClient = (client: Client): Cache => {\n  if (!(client as ClientWithCache)._react) {\n    const reclaim = new Set();\n    const map = new Map<number, CacheEntry>();\n\n    if (client.operations$ /* not available in mocks */) {\n      pipe(\n        client.operations$,\n        subscribe(operation => {\n          if (operation.kind === 'teardown' && reclaim.has(operation.key)) {\n            reclaim.delete(operation.key);\n            map.delete(operation.key);\n          }\n        })\n      );\n    }\n\n    (client as ClientWithCache)._react = {\n      get(key) {\n        return map.get(key);\n      },\n      set(key, value) {\n        reclaim.delete(key);\n        map.set(key, value);\n      },\n      dispose(key) {\n        reclaim.add(key);\n      },\n    };\n  }\n\n  return (client as ClientWithCache)._react!;\n};\n", "/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { Source, pipe, subscribe, onEnd, onPush, takeWhile } from 'wonka';\nimport * as React from 'react';\n\nimport {\n  GraphQLRequestParams,\n  AnyVariables,\n  Client,\n  CombinedError,\n  OperationContext,\n  RequestPolicy,\n  OperationResult,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useRequest } from './useRequest';\nimport { getCacheForClient } from './cache';\n\nimport {\n  deferDispatch,\n  initialState,\n  computeNextState,\n  hasDepsChanged,\n} from './state';\n\n/** Input arguments for the {@link useQuery} hook.\n *\n * @param query - The GraphQL query that `useQuery` executes.\n * @param variables - The variables for the GraphQL query that `useQuery` executes.\n */\nexport type UseQueryArgs<\n  Variables extends AnyVariables = AnyVariables,\n  Data = any\n> = {\n  /** Updates the {@link RequestPolicy} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `requestPolicy` modifies the {@link RequestPolicy} of the GraphQL query operation\n   * that `useQuery` executes, and indicates a caching strategy for cache exchanges.\n   *\n   * For example, when set to `'cache-and-network'`, {@link useQuery} will\n   * receive a cached result with `stale: true` and an API request will be\n   * sent in the background.\n   *\n   * @see {@link OperationContext.requestPolicy} for where this value is set.\n   */\n  requestPolicy?: RequestPolicy;\n  /** Updates the {@link OperationContext} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `context` may be passed to {@link useQuery}, to update the {@link OperationContext}\n   * of a query operation. This may be used to update the `context` that exchanges\n   * will receive for a single hook.\n   *\n   * Hint: This should be wrapped in a `useMemo` hook, to make sure that your\n   * component doesn’t infinitely update.\n   *\n   * @example\n   * ```ts\n   * const [result, reexecute] = useQuery({\n   *   query,\n   *   context: useMemo(() => ({\n   *     additionalTypenames: ['Item'],\n   *   }), [])\n   * });\n   * ```\n   */\n  context?: Partial<OperationContext>;\n  /** Prevents {@link useQuery} from automatically executing GraphQL query operations.\n   *\n   * @remarks\n   * `pause` may be set to `true` to stop {@link useQuery} from executing\n   * automatically. The hook will stop receiving updates from the {@link Client}\n   * and won’t execute the query operation, until either it’s set to `false`\n   * or the {@link UseQueryExecute} function is called.\n   *\n   * @see {@link https://urql.dev/goto/docs/basics/react-preact/#pausing-usequery} for\n   * documentation on the `pause` option.\n   */\n  pause?: boolean;\n} & GraphQLRequestParams<Data, Variables>;\n\n/** State of the current query, your {@link useQuery} hook is executing.\n *\n * @remarks\n * `UseQueryState` is returned (in a tuple) by {@link useQuery} and\n * gives you the updating {@link OperationResult} of GraphQL queries.\n *\n * Even when the query and variables passed to {@link useQuery} change,\n * this state preserves the prior state and sets the `fetching` flag to\n * `true`.\n * This allows you to display the previous state, while implementing\n * a separate loading indicator separately.\n */\nexport interface UseQueryState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> {\n  /** Indicates whether `useQuery` is waiting for a new result.\n   *\n   * @remarks\n   * When `useQuery` is passed a new query and/or variables, it will\n   * start executing the new query operation and `fetching` is set to\n   * `true` until a result arrives.\n   *\n   * Hint: This is subtly different than whether the query is actually\n   * fetching, and doesn’t indicate whether a query is being re-executed\n   * in the background. For this, see {@link UseQueryState.stale}.\n   */\n  fetching: boolean;\n  /** Indicates that the state is not fresh and a new result will follow.\n   *\n   * @remarks\n   * The `stale` flag is set to `true` when a new result for the query\n   * is expected and `useQuery` is waiting for it. This may indicate that\n   * a new request is being requested in the background.\n   *\n   * @see {@link OperationResult.stale} for the source of this value.\n   */\n  stale: boolean;\n  /** The {@link OperationResult.data} for the executed query. */\n  data?: Data;\n  /** The {@link OperationResult.error} for the executed query. */\n  error?: CombinedError;\n  /** The {@link OperationResult.extensions} for the executed query. */\n  extensions?: Record<string, any>;\n  /** The {@link Operation} that the current state is for.\n   *\n   * @remarks\n   * This is the {@link Operation} that is currently being executed.\n   * When {@link UseQueryState.fetching} is `true`, this is the\n   * last `Operation` that the current state was for.\n   */\n  operation?: Operation<Data, Variables>;\n}\n\n/** Triggers {@link useQuery} to execute a new GraphQL query operation.\n *\n * @param opts - optionally, context options that will be merged with the hook's\n * {@link UseQueryArgs.context} options and the `Client`’s options.\n *\n * @remarks\n * When called, {@link useQuery} will re-execute the GraphQL query operation\n * it currently holds, even if {@link UseQueryArgs.pause} is set to `true`.\n *\n * This is useful for executing a paused query or re-executing a query\n * and get a new network result, by passing a new request policy.\n *\n * ```ts\n * const [result, reexecuteQuery] = useQuery({ query });\n *\n * const refresh = () => {\n *   // Re-execute the query with a network-only policy, skipping the cache\n *   reexecuteQuery({ requestPolicy: 'network-only' });\n * };\n * ```\n */\nexport type UseQueryExecute = (opts?: Partial<OperationContext>) => void;\n\n/** Result tuple returned by the {@link useQuery} hook.\n *\n * @remarks\n * Similarly to a `useState` hook’s return value,\n * the first element is the {@link useQuery}’s result and state,\n * a {@link UseQueryState} object,\n * and the second is used to imperatively re-execute the query\n * via a {@link UseQueryExecute} function.\n */\nexport type UseQueryResponse<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = [UseQueryState<Data, Variables>, UseQueryExecute];\n\nconst isSuspense = (client: Client, context?: Partial<OperationContext>) =>\n  client.suspense && (!context || context.suspense !== false);\n\n/** Hook to run a GraphQL query and get updated GraphQL results.\n *\n * @param args - a {@link UseQueryArgs} object, to pass a `query`, `variables`, and options.\n * @returns a {@link UseQueryResponse} tuple of a {@link UseQueryState} result, and re-execute function.\n *\n * @remarks\n * `useQuery` allows GraphQL queries to be defined and executed.\n * Given {@link UseQueryArgs.query}, it executes the GraphQL query with the\n * context’s {@link Client}.\n *\n * The returned result updates when the `Client` has new results\n * for the query, and changes when your input `args` change.\n *\n * Additionally, if the `suspense` option is enabled on the `Client`,\n * the `useQuery` hook will suspend instead of indicating that it’s\n * waiting for a result via {@link UseQueryState.fetching}.\n *\n * @see {@link https://urql.dev/goto/urql/docs/basics/react-preact/#queries} for `useQuery` docs.\n *\n * @example\n * ```ts\n * import { gql, useQuery } from 'urql';\n *\n * const TodosQuery = gql`\n *   query { todos { id, title } }\n * `;\n *\n * const Todos = () => {\n *   const [result, reexecuteQuery] = useQuery({\n *     query: TodosQuery,\n *     variables: {},\n *   });\n *   // ...\n * };\n * ```\n */\nexport function useQuery<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(args: UseQueryArgs<Variables, Data>): UseQueryResponse<Data, Variables> {\n  const client = useClient();\n  const cache = getCacheForClient(client);\n  const suspense = isSuspense(client, args.context);\n  const request = useRequest(args.query, args.variables as Variables);\n\n  const source = React.useMemo(() => {\n    if (args.pause) return null;\n\n    const source = client.executeQuery(request, {\n      requestPolicy: args.requestPolicy,\n      ...args.context,\n    });\n\n    return suspense\n      ? pipe(\n          source,\n          onPush(result => {\n            cache.set(request.key, result);\n          })\n        )\n      : source;\n  }, [\n    cache,\n    client,\n    request,\n    suspense,\n    args.pause,\n    args.requestPolicy,\n    args.context,\n  ]);\n\n  const getSnapshot = React.useCallback(\n    (\n      source: Source<OperationResult<Data, Variables>> | null,\n      suspense: boolean\n    ): Partial<UseQueryState<Data, Variables>> => {\n      if (!source) return { fetching: false };\n\n      let result = cache.get(request.key);\n      if (!result) {\n        let resolve: (value: unknown) => void;\n\n        const subscription = pipe(\n          source,\n          takeWhile(() => (suspense && !resolve) || !result),\n          subscribe(_result => {\n            result = _result;\n            if (resolve) resolve(result);\n          })\n        );\n\n        if (result == null && suspense) {\n          const promise = new Promise(_resolve => {\n            resolve = _resolve;\n          });\n\n          cache.set(request.key, promise);\n          throw promise;\n        } else {\n          subscription.unsubscribe();\n        }\n      } else if (suspense && result != null && 'then' in result) {\n        throw result;\n      }\n\n      return (result as OperationResult<Data, Variables>) || { fetching: true };\n    },\n    [cache, request]\n  );\n\n  const deps = [\n    client,\n    request,\n    args.requestPolicy,\n    args.context,\n    args.pause,\n  ] as const;\n\n  const [state, setState] = React.useState(\n    () =>\n      [\n        source,\n        computeNextState(initialState, getSnapshot(source, suspense)),\n        deps,\n      ] as const\n  );\n\n  let currentResult = state[1];\n  if (source !== state[0] && hasDepsChanged(state[2], deps)) {\n    setState([\n      source,\n      (currentResult = computeNextState(\n        state[1],\n        getSnapshot(source, suspense)\n      )),\n      deps,\n    ]);\n  }\n\n  React.useEffect(() => {\n    const source = state[0];\n    const request = state[2][1];\n\n    let hasResult = false;\n\n    const updateResult = (result: Partial<UseQueryState<Data, Variables>>) => {\n      hasResult = true;\n      deferDispatch(setState, state => {\n        const nextResult = computeNextState(state[1], result);\n        return state[1] !== nextResult\n          ? [state[0], nextResult, state[2]]\n          : state;\n      });\n    };\n\n    if (source) {\n      const subscription = pipe(\n        source,\n        onEnd(() => {\n          updateResult({ fetching: false });\n        }),\n        subscribe(updateResult)\n      );\n\n      if (!hasResult) updateResult({ fetching: true });\n\n      return () => {\n        cache.dispose(request.key);\n        subscription.unsubscribe();\n      };\n    } else {\n      updateResult({ fetching: false });\n    }\n  }, [cache, state[0], state[2][1]]);\n\n  const executeQuery = React.useCallback(\n    (opts?: Partial<OperationContext>) => {\n      const context = {\n        requestPolicy: args.requestPolicy,\n        ...args.context,\n        ...opts,\n      };\n\n      deferDispatch(setState, state => {\n        const source = suspense\n          ? pipe(\n              client.executeQuery(request, context),\n              onPush(result => {\n                cache.set(request.key, result);\n              })\n            )\n          : client.executeQuery(request, context);\n        return [source, state[1], deps];\n      });\n    },\n    [\n      client,\n      cache,\n      request,\n      suspense,\n      args.requestPolicy,\n      args.context,\n      args.pause,\n    ]\n  );\n\n  return [currentResult, executeQuery];\n}\n", "/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { pipe, subscribe, onEnd } from 'wonka';\nimport * as React from 'react';\n\nimport {\n  GraphQLRequestParams,\n  AnyVariables,\n  CombinedError,\n  OperationContext,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useRequest } from './useRequest';\n\nimport {\n  deferDispatch,\n  initialState,\n  computeNextState,\n  hasDepsChanged,\n} from './state';\n\n/** Input arguments for the {@link useSubscription} hook.\n *\n * @param query - The GraphQL subscription document that `useSubscription` executes.\n * @param variables - The variables for the GraphQL subscription that `useSubscription` executes.\n */\nexport type UseSubscriptionArgs<\n  Variables extends AnyVariables = AnyVariables,\n  Data = any\n> = {\n  /** Prevents {@link useSubscription} from automatically starting GraphQL subscriptions.\n   *\n   * @remarks\n   * `pause` may be set to `true` to stop {@link useSubscription} from starting its subscription\n   * automatically. The hook will stop receiving updates from the {@link Client}\n   * and won’t start the subscription operation, until either it’s set to `false`\n   * or the {@link UseSubscriptionExecute} function is called.\n   */\n  pause?: boolean;\n  /** Updates the {@link OperationContext} for the executed GraphQL subscription operation.\n   *\n   * @remarks\n   * `context` may be passed to {@link useSubscription}, to update the {@link OperationContext}\n   * of a subscription operation. This may be used to update the `context` that exchanges\n   * will receive for a single hook.\n   *\n   * Hint: This should be wrapped in a `useMemo` hook, to make sure that your\n   * component doesn’t infinitely update.\n   *\n   * @example\n   * ```ts\n   * const [result, reexecute] = useSubscription({\n   *   query,\n   *   context: useMemo(() => ({\n   *     additionalTypenames: ['Item'],\n   *   }), [])\n   * });\n   * ```\n   */\n  context?: Partial<OperationContext>;\n} & GraphQLRequestParams<Data, Variables>;\n\n/** Combines previous data with an incoming subscription result’s data.\n *\n * @remarks\n * A `SubscriptionHandler` may be passed to {@link useSubscription} to\n * aggregate subscription results into a combined {@link UseSubscriptionState.data}\n * value.\n *\n * This is useful when a subscription event delivers a single item, while\n * you’d like to display a list of events.\n *\n * @example\n * ```ts\n * const NotificationsSubscription = gql`\n *   subscription { newNotification { id, text } }\n * `;\n *\n * const combineNotifications = (notifications = [], data) => {\n *   return [...notifications, data.newNotification];\n * };\n *\n * const [result, executeSubscription] = useSubscription(\n *   { query: NotificationsSubscription },\n *   combineNotifications,\n * );\n * ```\n */\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\n/** State of the current subscription, your {@link useSubscription} hook is executing.\n *\n * @remarks\n * `UseSubscriptionState` is returned (in a tuple) by {@link useSubscription} and\n * gives you the updating {@link OperationResult} of GraphQL subscriptions.\n *\n * If a {@link SubscriptionHandler} has been passed to `useSubscription` then\n * {@link UseSubscriptionState.data} is instead the updated data as returned\n * by the handler, otherwise it’s the latest result’s data.\n *\n * Hint: Even when the query and variables passed to {@link useSubscription} change,\n * this state preserves the prior state.\n */\nexport interface UseSubscriptionState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> {\n  /** Indicates whether `useSubscription`’s subscription is active.\n   *\n   * @remarks\n   * When `useSubscription` starts a subscription, the `fetching` flag\n   * is set to `true` and will remain `true` until the subscription\n   * completes on the API, or the {@link UseSubscriptionArgs.pause}\n   * flag is set to `true`.\n   */\n  fetching: boolean;\n  /** Indicates that the subscription result is not fresh.\n   *\n   * @remarks\n   * This is mostly unused for subscriptions and will rarely affect you, and\n   * is more relevant for queries.\n   *\n   * @see {@link OperationResult.stale} for the source of this value.\n   */\n  stale: boolean;\n  /** The {@link OperationResult.data} for the executed subscription, or data returned by a handler.\n   *\n   * @remarks\n   * `data` will be set to the last {@link OperationResult.data} value\n   * received for the subscription.\n   *\n   * It will instead be set to the values that {@link SubscriptionHandler}\n   * returned, if a handler has been passed to {@link useSubscription}.\n   */\n  data?: Data;\n  /** The {@link OperationResult.error} for the executed subscription. */\n  error?: CombinedError;\n  /** The {@link OperationResult.extensions} for the executed mutation. */\n  extensions?: Record<string, any>;\n  /** The {@link Operation} that the current state is for.\n   *\n   * @remarks\n   * This is the subscription {@link Operation} that is currently active.\n   * When {@link UseSubscriptionState.fetching} is `true`, this is the\n   * last `Operation` that the current state was for.\n   */\n  operation?: Operation<Data, Variables>;\n}\n\n/** Triggers {@link useSubscription} to reexecute a GraphQL subscription operation.\n *\n * @param opts - optionally, context options that will be merged with the hook's\n * {@link UseSubscriptionArgs.context} options and the `Client`’s options.\n *\n * @remarks\n * When called, {@link useSubscription} will restart the GraphQL subscription\n * operation it currently holds. If {@link UseSubscriptionArgs.pause} is set\n * to `true`, it will start executing the subscription.\n *\n * ```ts\n * const [result, executeSubscription] = useSubscription({\n *   query,\n *   pause: true,\n * });\n *\n * const start = () => {\n *   executeSubscription();\n * };\n * ```\n */\nexport type UseSubscriptionExecute = (opts?: Partial<OperationContext>) => void;\n\n/** Result tuple returned by the {@link useSubscription} hook.\n *\n * @remarks\n * Similarly to a `useState` hook’s return value,\n * the first element is the {@link useSubscription}’s state,\n * a {@link UseSubscriptionState} object,\n * and the second is used to imperatively re-execute or start the subscription\n * via a {@link UseMutationExecute} function.\n */\nexport type UseSubscriptionResponse<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = [UseSubscriptionState<Data, Variables>, UseSubscriptionExecute];\n\n/** Hook to run a GraphQL subscription and get updated GraphQL results.\n *\n * @param args - a {@link UseSubscriptionArgs} object, to pass a `query`, `variables`, and options.\n * @param handler - optionally, a {@link SubscriptionHandler} function to combine multiple subscription results.\n * @returns a {@link UseSubscriptionResponse} tuple of a {@link UseSubscriptionState} result, and an execute function.\n *\n * @remarks\n * `useSubscription` allows GraphQL subscriptions to be defined and executed.\n * Given {@link UseSubscriptionArgs.query}, it executes the GraphQL subscription with the\n * context’s {@link Client}.\n *\n * The returned result updates when the `Client` has new results\n * for the subscription, and `data` is updated with the result’s data\n * or with the `data` that a `handler` returns.\n *\n * @example\n * ```ts\n * import { gql, useSubscription } from 'urql';\n *\n * const NotificationsSubscription = gql`\n *   subscription { newNotification { id, text } }\n * `;\n *\n * const combineNotifications = (notifications = [], data) => {\n *   return [...notifications, data.newNotification];\n * };\n *\n * const Notifications = () => {\n *   const [result, executeSubscription] = useSubscription(\n *     { query: NotificationsSubscription },\n *     combineNotifications,\n *   );\n *   // ...\n * };\n * ```\n */\nexport function useSubscription<\n  Data = any,\n  Result = Data,\n  Variables extends AnyVariables = AnyVariables\n>(\n  args: UseSubscriptionArgs<Variables, Data>,\n  handler?: SubscriptionHandler<Data, Result>\n): UseSubscriptionResponse<Result, Variables> {\n  const client = useClient();\n  const request = useRequest(args.query, args.variables as Variables);\n\n  const handlerRef = React.useRef<\n    SubscriptionHandler<Data, Result> | undefined\n  >(handler);\n  handlerRef.current = handler;\n\n  const source = React.useMemo(\n    () =>\n      !args.pause ? client.executeSubscription(request, args.context) : null,\n    [client, request, args.pause, args.context]\n  );\n\n  const deps = [client, request, args.context, args.pause] as const;\n\n  const [state, setState] = React.useState(\n    () => [source, { ...initialState, fetching: !!source }, deps] as const\n  );\n\n  let currentResult = state[1];\n  if (source !== state[0] && hasDepsChanged(state[2], deps)) {\n    setState([\n      source,\n      (currentResult = computeNextState(state[1], { fetching: !!source })),\n      deps,\n    ]);\n  }\n\n  React.useEffect(() => {\n    const updateResult = (\n      result: Partial<UseSubscriptionState<Data, Variables>>\n    ) => {\n      deferDispatch(setState, state => {\n        const nextResult = computeNextState(state[1], result);\n        if (state[1] === nextResult) return state;\n        if (handlerRef.current && state[1].data !== nextResult.data) {\n          nextResult.data = handlerRef.current(\n            state[1].data,\n            nextResult.data!\n          ) as any;\n        }\n\n        return [state[0], nextResult as any, state[2]];\n      });\n    };\n\n    if (state[0]) {\n      return pipe(\n        state[0],\n        onEnd(() => {\n          updateResult({ fetching: !!source });\n        }),\n        subscribe(updateResult)\n      ).unsubscribe;\n    } else {\n      updateResult({ fetching: false });\n    }\n  }, [state[0]]);\n\n  // This is the imperative execute function passed to the user\n  const executeSubscription = React.useCallback(\n    (opts?: Partial<OperationContext>) => {\n      const source = client.executeSubscription(request, {\n        ...args.context,\n        ...opts,\n      });\n\n      deferDispatch(setState, state => [source, state[1], deps]);\n    },\n    [client, request, args.context, args.pause]\n  );\n\n  return [currentResult, executeSubscription];\n}\n", "import { ReactElement } from 'react';\nimport { AnyVariables, DocumentInput } from '@urql/core';\n\nimport { useMutation, UseMutationState, UseMutationExecute } from '../hooks';\n\n/** Props accepted by {@link Mutation}.\n *\n * @remarks\n * `MutationProps` are the props accepted by the {@link Mutation} component.\n *\n * The result, the {@link MutationState} object, will be passed to\n * a {@link MutationProps.children} function, passed as children\n * to the `Mutation` component.\n */\nexport interface MutationProps<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> {\n  /* The GraphQL mutation document that {@link useMutation} will execute. */\n  query: DocumentInput<Data, Variables>;\n  children(arg: MutationState<Data, Variables>): ReactElement<any>;\n}\n\n/** Object that {@link MutationProps.children} is called with.\n *\n * @remarks\n * This is an extented {@link UseMutationstate} with an added\n * {@link MutationState.executeMutation} method, which is usually\n * part of a tuple returned by {@link useMutation}.\n */\nexport interface MutationState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> extends UseMutationState<Data, Variables> {\n  /** Alias to {@link useMutation}’s `executeMutation` function. */\n  executeMutation: UseMutationExecute<Data, Variables>;\n}\n\n/** Component Wrapper around {@link useMutation} to run a GraphQL query.\n *\n * @remarks\n * `Mutation` is a component wrapper around the {@link useMutation} hook\n * that calls the {@link MutationProps.children} prop, as a function,\n * with the {@link MutationState} object.\n */\nexport function Mutation<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(props: MutationProps<Data, Variables>): ReactElement<any> {\n  const mutation = useMutation<Data, Variables>(props.query);\n  return props.children({ ...mutation[0], executeMutation: mutation[1] });\n}\n", "import { ReactElement } from 'react';\nimport { AnyVariables } from '@urql/core';\n\nimport {\n  useQuery,\n  UseQueryArgs,\n  UseQueryState,\n  UseQueryExecute,\n} from '../hooks';\n\n/** Props accepted by {@link Query}.\n *\n * @remarks\n * `QueryProps` are the props accepted by the {@link Query} component,\n * which is identical to {@link UseQueryArgs}.\n *\n * The result, the {@link QueryState} object, will be passed to\n * a {@link QueryProps.children} function, passed as children\n * to the `Query` component.\n */\nexport type QueryProps<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = UseQueryArgs<Variables, Data> & {\n  children(arg: QueryState<Data, Variables>): ReactElement<any>;\n};\n\n/** Object that {@link QueryProps.children} is called with.\n *\n * @remarks\n * This is an extented {@link UseQueryState} with an added\n * {@link QueryState.executeQuery} method, which is usually\n * part of a tuple returned by {@link useQuery}.\n */\nexport interface QueryState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> extends UseQueryState<Data, Variables> {\n  /** Alias to {@link useQuery}’s `executeQuery` function. */\n  executeQuery: UseQueryExecute;\n}\n\n/** Component Wrapper around {@link useQuery} to run a GraphQL query.\n *\n * @remarks\n * `Query` is a component wrapper around the {@link useQuery} hook\n * that calls the {@link QueryProps.children} prop, as a function,\n * with the {@link QueryState} object.\n */\nexport function Query<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(props: QueryProps<Data, Variables>): ReactElement<any> {\n  const query = useQuery<Data, Variables>(props);\n  return props.children({ ...query[0], executeQuery: query[1] });\n}\n", "import { ReactElement } from 'react';\nimport { AnyVariables } from '@urql/core';\n\nimport {\n  useSubscription,\n  UseSubscriptionArgs,\n  UseSubscriptionState,\n  UseSubscriptionExecute,\n  SubscriptionHandler,\n} from '../hooks';\n\n/** Props accepted by {@link Subscription}.\n *\n * @remarks\n * `SubscriptionProps` are the props accepted by the {@link Subscription} component,\n * which is identical to {@link UseSubscriptionArgs} with an added\n * {@link SubscriptionProps.handler} prop, which {@link useSubscription} usually\n * accepts as an additional argument.\n *\n * The result, the {@link SubscriptionState} object, will be passed to\n * a {@link SubscriptionProps.children} function, passed as children\n * to the `Subscription` component.\n */\nexport type SubscriptionProps<\n  Data = any,\n  Result = Data,\n  Variables extends AnyVariables = AnyVariables\n> = UseSubscriptionArgs<Variables, Data> & {\n  handler?: SubscriptionHandler<Data, Result>;\n  children(arg: SubscriptionState<Result, Variables>): ReactElement<any>;\n};\n\n/** Object that {@link SubscriptionProps.children} is called with.\n *\n * @remarks\n * This is an extented {@link UseSubscriptionState} with an added\n * {@link SubscriptionState.executeSubscription} method, which is usually\n * part of a tuple returned by {@link useSubscription}.\n */\nexport interface SubscriptionState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> extends UseSubscriptionState<Data, Variables> {\n  /** Alias to {@link useSubscription}’s `executeMutation` function. */\n  executeSubscription: UseSubscriptionExecute;\n}\n\n/** Component Wrapper around {@link useSubscription} to run a GraphQL subscription.\n *\n * @remarks\n * `Subscription` is a component wrapper around the {@link useSubscription} hook\n * that calls the {@link SubscriptionProps.children} prop, as a function,\n * with the {@link SubscriptionState} object.\n */\nexport function Subscription<\n  Data = any,\n  Result = Data,\n  Variables extends AnyVariables = AnyVariables\n>(props: SubscriptionProps<Data, Result, Variables>): ReactElement<any> {\n  const subscription = useSubscription<Data, Result, Variables>(\n    props,\n    props.handler\n  );\n\n  return props.children({\n    ...subscription[0],\n    executeSubscription: subscription[1],\n  });\n}\n"],
  "mappings": "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",
  "names": ["OBJ", "Context", "createContext", "Provider", "Consumer", "displayName", "useClient", "client", "useContext", "error", "console", "Error", "initialState", "fetching", "stale", "data", "extensions", "operation", "areOperationsEqual", "a", "b", "key", "computeNextState", "prevState", "result", "newState", "isShallowDifferent", "hasDepsChanged", "i", "l", "length", "reactSharedInternals", "__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED", "deferDispatch", "setState", "value", "ReactCurrentOwner", "current", "Promise", "resolve", "then", "useMutation", "query", "isMounted", "useRef", "state", "useState", "executeMutation", "useCallback", "variables", "context", "toPromise", "take", "filter", "hasNext", "onPush", "createRequest", "React", "useEffect", "useRequest", "prev", "undefined", "useMemo", "request", "getCacheForClient", "_react", "reclaim", "Set", "map", "Map", "operations$", "subscribe", "kind", "has", "delete", "get", "set", "dispose", "add", "isSuspense", "suspense", "useQuery", "args", "cache", "source", "pause", "executeQuery", "requestPolicy", "getSnapshot", "subscription", "_result", "takeWhile", "promise", "_resolve", "unsubscribe", "deps", "currentResult", "hasResult", "updateResult", "nextResult", "onEnd", "opts", "useSubscription", "handler", "handlerRef", "executeSubscription", "Mutation", "props", "mutation", "children", "Query", "Subscription"]
}
