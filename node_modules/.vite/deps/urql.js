import {
  C,
  CombinedError,
  cacheExchange,
  composeExchanges,
  createRequest,
  debugExchange,
  dedupExchange,
  fetchExchange,
  filter,
  formatDocument,
  gql,
  j,
  makeErrorResult,
  makeOperation,
  makeResult,
  mapExchange,
  maskTypename,
  mergeResultPatch,
  onEnd,
  onPush,
  ssrExchange,
  stringifyDocument,
  stringifyVariables,
  subscribe,
  subscriptionExchange,
  take,
  takeWhile,
  toPromise
} from "./chunk-6UYQSB3T.js";
import {
  require_react
} from "./chunk-ZVMIEU5R.js";
import {
  __toESM
} from "./chunk-UXIASGQL.js";

// node_modules/urql/dist/urql.es.js
var r = __toESM(require_react());
var c = {};
var v = r.createContext(c);
var f = v.Provider;
var l = v.Consumer;
v.displayName = "UrqlContext";
var useClient = () => {
  var e = r.useContext(v);
  if (e === c && true) {
    var t = "No client has been specified using urql's Provider. please create a client and add a Provider.";
    console.error(t);
    throw new Error(t);
  }
  return e;
};
var d = {
  fetching: false,
  stale: false,
  error: void 0,
  data: void 0,
  extensions: void 0,
  operation: void 0
};
var areOperationsEqual = (e, r2) => e === r2 || !(!e || !r2 || e.key !== r2.key);
var computeNextState = (e, r2) => {
  var t = {
    ...e,
    ...r2,
    data: void 0 !== r2.data || r2.error ? r2.data : e.data,
    fetching: !!r2.fetching,
    stale: !!r2.stale
  };
  return ((e2, r3) => {
    for (var t2 in e2) {
      if (!(t2 in r3)) {
        return true;
      }
    }
    for (var a in r3) {
      if ("operation" === a ? !areOperationsEqual(e2[a], r3[a]) : e2[a] !== r3[a]) {
        return true;
      }
    }
    return false;
  })(e, t) ? t : e;
};
var hasDepsChanged = (e, r2) => {
  for (var t = 0, a = r2.length; t < a; t++) {
    if (e[t] !== r2[t]) {
      return true;
    }
  }
  return false;
};
var p = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function deferDispatch(e, r2) {
  if (p && p.ReactCurrentOwner && p.ReactCurrentOwner.current) {
    Promise.resolve(r2).then(e);
  } else {
    e(r2);
  }
}
function useMutation(i) {
  var s = r.useRef(true);
  var o = useClient();
  var [c2, v2] = r.useState(d);
  var f2 = r.useCallback((r2, c3) => {
    deferDispatch(v2, {
      ...d,
      fetching: true
    });
    return toPromise(take(1)(filter((e) => !e.hasNext)(onPush((e) => {
      if (s.current) {
        deferDispatch(v2, {
          fetching: false,
          stale: e.stale,
          data: e.data,
          error: e.error,
          extensions: e.extensions,
          operation: e.operation
        });
      }
    })(o.executeMutation(createRequest(i, r2), c3 || {})))));
  }, [o, i, v2]);
  r.useEffect(() => {
    s.current = true;
    return () => {
      s.current = false;
    };
  }, []);
  return [c2, f2];
}
function useRequest(t, a) {
  var n = r.useRef(void 0);
  return r.useMemo(() => {
    var r2 = createRequest(t, a);
    if (void 0 !== n.current && n.current.key === r2.key) {
      return n.current;
    } else {
      n.current = r2;
      return r2;
    }
  }, [t, a]);
}
var getCacheForClient = (e) => {
  if (!e._react) {
    var r2 = /* @__PURE__ */ new Set();
    var t = /* @__PURE__ */ new Map();
    if (e.operations$) {
      subscribe((e2) => {
        if ("teardown" === e2.kind && r2.has(e2.key)) {
          r2.delete(e2.key);
          t.delete(e2.key);
        }
      })(e.operations$);
    }
    e._react = {
      get: (e2) => t.get(e2),
      set(e2, a) {
        r2.delete(e2);
        t.set(e2, a);
      },
      dispose(e2) {
        r2.add(e2);
      }
    };
  }
  return e._react;
};
var isSuspense = (e, r2) => e.suspense && (!r2 || false !== r2.suspense);
function useQuery(e) {
  var t = useClient();
  var a = getCacheForClient(t);
  var n = isSuspense(t, e.context);
  var c2 = useRequest(e.query, e.variables);
  var v2 = r.useMemo(() => {
    if (e.pause) {
      return null;
    }
    var r2 = t.executeQuery(c2, {
      requestPolicy: e.requestPolicy,
      ...e.context
    });
    return n ? onPush((e2) => {
      a.set(c2.key, e2);
    })(r2) : r2;
  }, [a, t, c2, n, e.pause, e.requestPolicy, e.context]);
  var f2 = r.useCallback((e2, r2) => {
    if (!e2) {
      return {
        fetching: false
      };
    }
    var t2 = a.get(c2.key);
    if (!t2) {
      var n2;
      var u = subscribe((e3) => {
        t2 = e3;
        if (n2) {
          n2(t2);
        }
      })(takeWhile(() => r2 && !n2 || !t2)(e2));
      if (null == t2 && r2) {
        var o = new Promise((e3) => {
          n2 = e3;
        });
        a.set(c2.key, o);
        throw o;
      } else {
        u.unsubscribe();
      }
    } else if (r2 && null != t2 && "then" in t2) {
      throw t2;
    }
    return t2 || {
      fetching: true
    };
  }, [a, c2]);
  var l2 = [t, c2, e.requestPolicy, e.context, e.pause];
  var [p2, h] = r.useState(() => [v2, computeNextState(d, f2(v2, n)), l2]);
  var y = p2[1];
  if (v2 !== p2[0] && hasDepsChanged(p2[2], l2)) {
    h([v2, y = computeNextState(p2[1], f2(v2, n)), l2]);
  }
  r.useEffect(() => {
    var e2 = p2[0];
    var r2 = p2[2][1];
    var t2 = false;
    var updateResult = (e3) => {
      t2 = true;
      deferDispatch(h, (r3) => {
        var t3 = computeNextState(r3[1], e3);
        return r3[1] !== t3 ? [r3[0], t3, r3[2]] : r3;
      });
    };
    if (e2) {
      var n2 = subscribe(updateResult)(onEnd(() => {
        updateResult({
          fetching: false
        });
      })(e2));
      if (!t2) {
        updateResult({
          fetching: true
        });
      }
      return () => {
        a.dispose(r2.key);
        n2.unsubscribe();
      };
    } else {
      updateResult({
        fetching: false
      });
    }
  }, [a, p2[0], p2[2][1]]);
  var x = r.useCallback((r2) => {
    var i = {
      requestPolicy: e.requestPolicy,
      ...e.context,
      ...r2
    };
    deferDispatch(h, (e2) => [n ? onPush((e3) => {
      a.set(c2.key, e3);
    })(t.executeQuery(c2, i)) : t.executeQuery(c2, i), e2[1], l2]);
  }, [t, a, c2, n, e.requestPolicy, e.context, e.pause]);
  return [y, x];
}
function useSubscription(e, t) {
  var a = useClient();
  var n = useRequest(e.query, e.variables);
  var u = r.useRef(t);
  u.current = t;
  var s = r.useMemo(() => !e.pause ? a.executeSubscription(n, e.context) : null, [a, n, e.pause, e.context]);
  var c2 = [a, n, e.context, e.pause];
  var [v2, f2] = r.useState(() => [s, {
    ...d,
    fetching: !!s
  }, c2]);
  var l2 = v2[1];
  if (s !== v2[0] && hasDepsChanged(v2[2], c2)) {
    f2([s, l2 = computeNextState(v2[1], {
      fetching: !!s
    }), c2]);
  }
  r.useEffect(() => {
    var updateResult = (e2) => {
      deferDispatch(f2, (r2) => {
        var t2 = computeNextState(r2[1], e2);
        if (r2[1] === t2) {
          return r2;
        }
        if (u.current && r2[1].data !== t2.data) {
          t2.data = u.current(r2[1].data, t2.data);
        }
        return [r2[0], t2, r2[2]];
      });
    };
    if (v2[0]) {
      return subscribe(updateResult)(onEnd(() => {
        updateResult({
          fetching: !!s
        });
      })(v2[0])).unsubscribe;
    } else {
      updateResult({
        fetching: false
      });
    }
  }, [v2[0]]);
  var p2 = r.useCallback((r2) => {
    var t2 = a.executeSubscription(n, {
      ...e.context,
      ...r2
    });
    deferDispatch(f2, (e2) => [t2, e2[1], c2]);
  }, [a, n, e.context, e.pause]);
  return [l2, p2];
}
function Mutation(e) {
  var r2 = useMutation(e.query);
  return e.children({
    ...r2[0],
    executeMutation: r2[1]
  });
}
function Query(e) {
  var r2 = useQuery(e);
  return e.children({
    ...r2[0],
    executeQuery: r2[1]
  });
}
function Subscription(e) {
  var r2 = useSubscription(e, e.handler);
  return e.children({
    ...r2[0],
    executeSubscription: r2[1]
  });
}
export {
  C as Client,
  CombinedError,
  l as Consumer,
  v as Context,
  Mutation,
  f as Provider,
  Query,
  Subscription,
  cacheExchange,
  composeExchanges,
  j as createClient,
  createRequest,
  debugExchange,
  dedupExchange,
  mapExchange as errorExchange,
  fetchExchange,
  formatDocument,
  gql,
  makeErrorResult,
  makeOperation,
  makeResult,
  mapExchange,
  maskTypename,
  mergeResultPatch,
  ssrExchange,
  stringifyDocument,
  stringifyVariables,
  subscriptionExchange,
  useClient,
  useMutation,
  useQuery,
  useSubscription
};
//# sourceMappingURL=urql.js.map
